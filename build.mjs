// @ts-check
/* eslint-env es2022 */
import { exec as execAsync, execSync } from 'child_process';
import { readFileSync, writeFileSync } from 'fs';
import { readFile, writeFile } from 'fs/promises';
import globPkg from 'glob';

const glob = globPkg.sync;

const pkg = await readFile('./package.json').then((res) => JSON.parse(res.toString()));

// ---------------------------------------------------------------------------

const makePackageJson = (
  /** @type {string} */ outDir,
  /** @type {Record<string, unknown> | undefined} */ extraFields
) => {
  const { dist_package_json } = pkg;

  delete pkg.scripts;
  delete pkg.engines;
  delete pkg.private;
  delete pkg.hxmstyle;
  delete pkg.devDependencies;
  delete pkg.browserslist;
  delete pkg.dist_package_json;

  Object.assign(pkg, dist_package_json, extraFields);

  writeFileSync(outDir + '/package.json', JSON.stringify(pkg, null, '\t'));
};

// ===========================================================================

/** @type {Record<string,unknown>} */
const opts = process.argv.slice(2).reduce((map, arg) => {
  const [key, value] = arg.replace(/^-+/, '').split('=');
  map[key] = value == null ? true : value;
  return map;
}, {});

// ---------------------------------------------------------------------------

/** @typedef {{ compilerOptions: Record<string, unknown>; include: string[]; exlude?: string[] }}  TSConfig */
const tscBuild = (
  /** @type {string} */ name,
  /** @type {TSConfig | undefined} */ config,
  /** @type {boolean | undefined} */ watch
) => {
  const cfgFile = `tsconfig.build.${name}.json`;
  writeFileSync(
    cfgFile,
    `// This file is auto-generated by build.mjs\n${JSON.stringify(
      { extends: './tsconfig.json', ...config },
      null,
      '\t'
    )}`
  );
  if (watch) {
    execAsync(`yarn run tsc --project ${cfgFile} --watch --preserveWatchOutput`);
  } else {
    execSync(`yarn run tsc --project ${cfgFile}`);
  }
};

// ---------------------------------------------------------------------------

const addReferenePathsToIndex = (
  /** @type {Array<string>} */ entryPoints,
  /** @type {string} */ distFolder
) => {
  const dtsify = (tsFilePath) => tsFilePath.replace(/\.(tsx?)$/, '.d.$1');
  const indexTsFile = entryPoints.find((filePath) =>
    /(?:^|\/)index.tsx?$/.test(filePath)
  );

  if (indexTsFile) {
    const extraEntryPaths = entryPoints
      .filter((filePath) => filePath !== indexTsFile)
      .map(dtsify)
      .map((declFile) => `/// <reference path="./${declFile}" />`);
    if (extraEntryPaths.length > 0) {
      const indexDeclFile = `${distFolder}/${dtsify(indexTsFile)}`;
      const indexDecls =
        extraEntryPaths.join('\n') + `\n\n` + readFileSync(indexDeclFile);
      writeFileSync(indexDeclFile, indexDecls);
    }
  }
};

// ---------------------------------------------------------------------------

const testsDir = '__tests';
const outDir = '_npm-lib';
const srcDir = 'src';

// ---------------------------------------------------------------------------
// Build Unit Tests

execSync(`rm -rf ${testsDir}`);
tscBuild(
  'tests',
  {
    compilerOptions: {
      module: 'commonjs',
      target: 'esnext',
      outDir: testsDir,
    },
    include: [
      `${srcDir}/**/*.tests.ts`,
      // And the compiler test CSS.js files
      `${srcDir}/**/*.css.ts`,
    ],
  },
  !!opts.dev
);

if (!opts.dev) {
  // ---------------------------------------------------------------------------
  // Build Library

  execSync(
    [
      `rm -rf ${outDir}`,
      `mkdir ${outDir} ${outDir}/esm`,
      `cp README.md CHANGELOG.md ${outDir}`,
    ].join(' && ')
  );
  writeFile(`${outDir}/esm/package.json`, JSON.stringify({ type: 'module' }));

  const entryPoints = glob('*.ts', {
    cwd: srcDir,
    ignore: ['**/*.{tests,privates}.ts'],
  });

  makePackageJson(outDir, {
    exports: entryPoints.reduce((exports, file) => {
      const token = file.replace(/\.ts$/, '');
      const expToken = token === 'index' ? '.' : `./${token}`;
      exports[expToken] = {
        import: `./esm/${token}.js`,
        require: `./${token}.js`,
      };
      return exports;
    }, {}),
  });

  const include = entryPoints.map((fileName) => `${srcDir}/${fileName}`);

  tscBuild('lib-cjs', {
    compilerOptions: {
      module: 'commonjs',
      target: 'ES2015',
      declaration: true,
      outDir,
    },
    include: include.concat([`${srcDir}/bin/cli.ts`]),
  });
  addReferenePathsToIndex(entryPoints, outDir);

  const esmOutDir = `${outDir}/esm`;
  tscBuild('lib-esm', {
    compilerOptions: {
      module: 'esnext',
      target: 'ES2015',
      declaration: true,
      outDir: esmOutDir,
    },
    include,
  });
  addReferenePathsToIndex(entryPoints, esmOutDir);
} else {
  execSync(`rm -rf ${outDir}`);
}
