/* eslint-env es2022 */
import { exec as execAsync, execSync as exec } from 'child_process';
import { writeFileSync } from 'fs';
import { readFile, writeFile } from 'fs/promises';
import globPkg from 'glob';

const glob = globPkg.sync;

const pkg = await readFile('./package.json').then((res) => JSON.parse(res));

// ---------------------------------------------------------------------------

const makePackageJson = (outDir, extraFields) => {
  const { dist_package_json } = pkg;

  delete pkg.scripts;
  delete pkg.engines;
  delete pkg.private;
  delete pkg.hxmstyle;
  delete pkg.devDependencies;
  delete pkg.dist_package_json;

  Object.assign(pkg, dist_package_json, extraFields);

  writeFileSync(outDir + '/package.json', JSON.stringify(pkg, null, '\t'));
};

// ===========================================================================

const opts = process.argv.slice(2).reduce(
  /* <Record<string,unknown>> */ (map, arg) => {
    const [key, value] = arg.replace(/^-+/, '').split('=');
    map[key] = value == null ? true : value;
    return map;
  },
  {}
);

// ---------------------------------------------------------------------------

const tscBuild = (name, config, watch) => {
  const cfgFile = `tsconfig.build.${name}.json`;
  writeFileSync(
    cfgFile,
    `// This file is auto-generated by build.mjs\n${JSON.stringify(
      { extends: './tsconfig.json', ...config },
      null,
      '\t'
    )}`
  );
  const tsWatch = watch ? ` --watch --preserveWatchOutput` : ``;
  execAsync(`yarn run tsc --project ${cfgFile} ${tsWatch}`);
};

// ---------------------------------------------------------------------------

const testsDir = '__tests';
const outDir = '_npm-lib';
const srcDir = 'src';

// ---------------------------------------------------------------------------
// Build Unit Tests

exec(`rm -rf ${testsDir}`);
tscBuild(
  'tests',
  {
    compilerOptions: {
      module: 'commonjs',
      target: 'esnext',
      outDir: testsDir,
    },
    include: [
      `${srcDir}/**/*.tests.ts`,
      // And the compiler test CSS.js files
      `${srcDir}/**/*.css.ts`,
    ],
  },
  opts.dev
);

if (!opts.dev) {
  // ---------------------------------------------------------------------------
  // Build Library

  exec(
    [
      `rm -rf ${outDir}`,
      `mkdir ${outDir} ${outDir}/esm`,
      `cp README.md CHANGELOG.md ${outDir}`,
    ].join(' && ')
  );
  writeFile(`${outDir}/esm/package.json`, JSON.stringify({ type: 'module' }));

  makePackageJson(outDir, {
    exports: glob('*.ts', { cwd: srcDir, ignore: '*.tests.ts' }).reduce(
      (exports, file) => {
        const token = file.replace(/\.ts$/, '');
        const expToken = token === 'index' ? '.' : `./${token}`;
        exports[expToken] = {
          import: `./esm/${token}.js`,
          require: `./${token}.js`,
        };
        return exports;
      },
      {}
    ),
  });

  tscBuild('lib-cjs', {
    compilerOptions: {
      module: 'commonjs',
      target: 'ES2015',
      declaration: true,
      outDir,
    },
    include: [
      `${srcDir}/*.ts`,
      // also build the CLI compiler
      `${srcDir}/bin/cli.ts`,
    ],
    exclude: [`${srcDir}/*.tests.ts`],
  });

  tscBuild('lib-esm', {
    compilerOptions: {
      module: 'esnext',
      target: 'ES2015',
      declaration: true,
      outDir: `${outDir}/esm`,
    },
    include: [`${srcDir}/*.ts`],
    exclude: [`${srcDir}/*.tests.ts`],
  });
} else {
  exec(`rm -rf ${outDir}`);
}
